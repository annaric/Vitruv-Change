@Ecore(nsURI="http://tools.vitruv/EChange/Compound/1.0")
@GenModel(modelName="Change") //@GenModel(editDirectory="/tools.vitruv.framework.change.echange.edit/src", editorDirectory="/tools.vitruv.framework.change.echange.editor/src", modelName="Change", modelPluginClass="", editPluginClass="tools.vitruv.framework.change.provider.ChangeEditPlugin", editorPluginClass="tools.vitruv.framework.change.echange.presentation.ChangeEditorPlugin", testsDirectory="tools.vitruv.framework.change.echange.tests/src", testSuiteClass="tools.vitruv.framework.change.echange.tests.ChangeAllTests", importerID="org.eclipse.emf.importer.ecore", editorPluginID="tools.vitruv.framework.change.echange.editor", testsPluginID="tools.vitruv.framework.change.echange.tests")
package tools.vitruv.framework.change.echange.compound

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.resource.ResourceSet
import tools.vitruv.framework.change.echange.EChange
import tools.vitruv.framework.change.echange.AdditiveEChange
import tools.vitruv.framework.change.echange.AtomicEChange
import tools.vitruv.framework.change.echange.SubtractiveEChange
import tools.vitruv.framework.change.echange.eobject.EObjectAddedEChange
import tools.vitruv.framework.change.echange.eobject.EObjectSubtractedEChange
import tools.vitruv.framework.change.echange.feature.FeatureEChange
import tools.vitruv.framework.change.echange.feature.list.InsertInListEChange
import tools.vitruv.framework.change.echange.feature.list.RemoveFromListEChange
import tools.vitruv.framework.change.echange.feature.reference.UpdateReferenceEChange
import tools.vitruv.framework.change.echange.root.InsertRootEObject
import tools.vitruv.framework.change.echange.eobject.CreateEObject
import tools.vitruv.framework.change.echange.root.RemoveRootEObject
import tools.vitruv.framework.change.echange.eobject.DeleteEObject
import tools.vitruv.framework.change.echange.feature.reference.InsertEReference
import tools.vitruv.framework.change.echange.feature.reference.RemoveEReference
import tools.vitruv.framework.change.echange.feature.reference.ReplaceSingleValuedEReference
import org.eclipse.emf.common.util.BasicEList
import tools.vitruv.framework.change.echange.feature.attribute.SubtractiveAttributeEChange

type EObj wraps EObject
type EFeat wraps EStructuralFeature
type ResourceSet wraps ResourceSet

abstract class CompoundEChange extends tools.vitruv.framework.change.echange.EChange {
	op unique AtomicEChange[+] getAtomicChanges()
	op boolean isResolved() {
		for (AtomicEChange change : getAtomicChanges()) {
			if (!change.isResolved()) {
				return false
			}
		}
		return super.isResolved()
	}
	op EChange resolveApply(ResourceSet resourceSet) {
		resolve(resourceSet, true)
	}
	op EChange resolveRevert(ResourceSet resourceSet) {
		resolve(resourceSet, false)
	}
	op EChange resolve(ResourceSet resourceSet, boolean applyChange) {
		if (!isResolved) {
			val resolvedChange = super.resolveApply(resourceSet) as CompoundEChange
			if (resolvedChange == null) {
				// resolving the super class attributes failed
				return null				
			}
			
			resolvedChange.resolveAtomicChanges(resourceSet, applyChange)
			
			for (AtomicEChange change : resolvedChange.atomicChanges) {
				if (!change.isResolved) {
					return this
				}
			}
			return resolvedChange
		}
		return this
	}
	
	/**
	 * Resolves all atomic changes in the compound change
	 * in the correct order.
	 * @param resourceSet The resource set which the proxy elements will be resolved to.
	 * @param applyChange Indicates whether the change will be applied or reverted
	 * 		after resolving. The changes needs to be resolved from the first to the last change.
	 * 		If {@code applyChange} is {@code false} the changes needs to be resolved
	 * 		from the last change to the first change.
	 */
	op void resolveAtomicChanges(ResourceSet resourceSet, boolean applyChange)
}

class MoveEObject<A extends EObj, B extends EObj, T extends EObj> extends CompoundEChange {
	refers UpdateReferenceEChange<A> subtractWhereChange
	contains EObjectSubtractedEChange<T>[1] subtractWhatChange
	refers UpdateReferenceEChange<B> addWhereChange
	contains EObjectAddedEChange<T>[1] addWhatChange
	op unique AtomicEChange[+] getAtomicChanges() {
		val list = new BasicEList<AtomicEChange>();
		val subWhereChange = getSubtractWhereChange();
		if (subWhereChange != null) {
			list.add(subWhereChange);
		}
		list.add(getSubtractWhatChange());
		val addWhereChange = getAddWhereChange();
		if (addWhereChange != null) {
		    list.add(addWhereChange);
		}
		list.add(getAddWhatChange());
		
		return list;
		
	}
}

class ExplicitUnsetEFeature<A extends EObj, T extends Object> extends CompoundSubtraction<T, SubtractiveAttributeEChange<A,T>> {
	op unique AtomicEChange[+] getAtomicChanges() {
		return subtractiveChanges.map[it]
	}
}

class ReplaceInEList<A extends EObj, F extends EFeat, T extends EObj, R extends RemoveFromListEChange<A, F, T> & FeatureEChange<A, F> & SubtractiveEChange<T>, I extends InsertInListEChange<A, F, T> & FeatureEChange<A, F> & AdditiveEChange<T>> extends CompoundEChange {
	contains R[1] removeChange
	contains I[1] insertChange
	op unique AtomicEChange[+] getAtomicChanges() {
		val list = new BasicEList<AtomicEChange>();
		list.add(getRemoveChange());
		list.add(getInsertChange());
		return list;
	}
	op void resolveAtomicChanges(ResourceSet resourceSet, boolean applyChange) {

	}
}

class CompoundSubtraction<T extends Object, S extends SubtractiveEChange<T>> extends CompoundEChange {
	contains S[+] subtractiveChanges
	op unique AtomicEChange[+] getAtomicChanges() {
		val result = new BasicEList<AtomicEChange>();
		result.addAll(subtractiveChanges);
		return result;
	}
	op void resolveAtomicChanges(ResourceSet resourceSet, boolean applyChange) {
		if (applyChange) {
			for (var i = 0; i < subtractiveChanges.size; i++) {
				subtractiveChanges.set(i, subtractiveChanges.get(i).resolveApply(resourceSet) as S)
			}
		} else {
			for (var i = subtractiveChanges.size - 1; i >= 0; i--) {
				subtractiveChanges.set(i, subtractiveChanges.get(i).resolveRevert(resourceSet) as S)				
			}
		}
	}
}

class CompoundAddition<T extends Object, S extends AdditiveEChange<T>> extends CompoundEChange {
	contains S[+] additiveChanges
	op unique AtomicEChange[+] getAtomicChanges() {
		val result = new BasicEList<AtomicEChange>();
		result.addAll(additiveChanges);
		return result;
	}
	op void resolveAtomicChanges(ResourceSet resourceSet, boolean applyChange) {
		if (applyChange) {
			for (var i = 0; i < additiveChanges.size; i++) {
				additiveChanges.set(i, additiveChanges.get(i).resolveApply(resourceSet) as S)
			}
		} else {
			for (var i = additiveChanges.size - 1; i >= 0; i--) {
				additiveChanges.set(i, additiveChanges.get(i).resolveRevert(resourceSet) as S)				
			}
		}
	}
}

abstract class CreateAndInsertEObject<T extends EObj, C extends EObjectAddedEChange<T>> extends CompoundEChange {
	contains CreateEObject<T>[1] createChange
	contains C[1] insertChange
	op unique AtomicEChange[+] getAtomicChanges() {
		val result = new BasicEList();
		result.add(createChange);
		result.add(insertChange);
		return result;
	}
	op void resolveAtomicChanges(ResourceSet resourceSet, boolean applyChange) {
		if (applyChange) {
			createChange = createChange.resolveApply(resourceSet) as CreateEObject<T>
			insertChange = insertChange.resolveApply(resourceSet) as C
		} else {
			insertChange = insertChange.resolveRevert(resourceSet) as C
			createChange = createChange.resolveRevert(resourceSet) as CreateEObject<T>
		}
	}
}

abstract class RemoveAndDeleteEObject<T extends EObj, C extends EObjectSubtractedEChange<T>> extends CompoundEChange {
	contains C[1] removeChange
	contains DeleteEObject<T>[1] deleteChange
	op unique AtomicEChange[+] getAtomicChanges() {
		val result = new BasicEList();
		result.add(removeChange);
		result.add(deleteChange);
		return result;
	}
	op void resolveAtomicChanges(ResourceSet resourceSet, boolean applyChange) {
		if (applyChange) {
			removeChange = removeChange.resolveApply(resourceSet) as C
			deleteChange = deleteChange.resolveApply(resourceSet) as DeleteEObject<T>
		} else {
			deleteChange = deleteChange.resolveRevert(resourceSet) as DeleteEObject<T>
			removeChange = removeChange.resolveRevert(resourceSet) as C
		}
	}
}

class CreateAndInsertRoot<T extends EObj> extends CreateAndInsertEObject<T, InsertRootEObject<T>> {}

class RemoveAndDeleteRoot<T extends EObj> extends RemoveAndDeleteEObject<T, RemoveRootEObject<T>> {}

class CreateAndInsertNonRoot<A extends EObj, T extends EObj> extends CreateAndInsertEObject<T, InsertEReference<A, T>> {}

class RemoveAndDeleteNonRoot<A extends EObj, T extends EObj> extends RemoveAndDeleteEObject<T, RemoveEReference<A, T>> {}

class CreateAndReplaceAndDeleteNonRoot<A extends EObj, T extends EObj> extends CompoundEChange {
	contains CreateEObject<T>[1] createChange
	contains ReplaceSingleValuedEReference<A, T>[1] replaceChange
	contains DeleteEObject<T>[1] deleteChange
	op unique AtomicEChange[+] getAtomicChanges() {
		val result = new BasicEList();
		result.add(createChange);
		result.add(replaceChange);
		result.add(deleteChange);
		return result;
	}
	op void resolveAtomicChanges(ResourceSet resourceSet, boolean applyChange) {
		if (applyChange) {
			createChange = createChange.resolveApply(resourceSet) as CreateEObject<T>
			replaceChange = replaceChange.resolveApply(resourceSet) as ReplaceSingleValuedEReference<A, T>
			deleteChange = deleteChange.resolveApply(resourceSet) as DeleteEObject<T>
		} else {
			deleteChange = deleteChange.resolveRevert(resourceSet) as DeleteEObject<T>	
			replaceChange = replaceChange.resolveRevert(resourceSet) as ReplaceSingleValuedEReference<A, T>
			createChange = createChange.resolveRevert(resourceSet) as CreateEObject<T>
		}
	}
}
