@Ecore(nsURI="http://tools.vitruv/EChange/Compound/1.0")
@GenModel(modelName="Change") //@GenModel(editDirectory="/tools.vitruv.framework.change.echange.edit/src", editorDirectory="/tools.vitruv.framework.change.echange.editor/src", modelName="Change", modelPluginClass="", editPluginClass="tools.vitruv.framework.change.provider.ChangeEditPlugin", editorPluginClass="tools.vitruv.framework.change.echange.presentation.ChangeEditorPlugin", testsDirectory="tools.vitruv.framework.change.echange.tests/src", testSuiteClass="tools.vitruv.framework.change.echange.tests.ChangeAllTests", importerID="org.eclipse.emf.importer.ecore", editorPluginID="tools.vitruv.framework.change.echange.editor", testsPluginID="tools.vitruv.framework.change.echange.tests")
package tools.vitruv.framework.change.echange.compound

import org.eclipse.emf.common.command.Command
import org.eclipse.emf.common.util.BasicEList
import org.eclipse.emf.ecore.EAttribute
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.emf.ecore.util.EcoreUtil
import tools.vitruv.framework.change.echange.resolve.CompoundEChangeResolver
import tools.vitruv.framework.change.echange.AdditiveEChange
import tools.vitruv.framework.change.echange.AtomicEChange
import tools.vitruv.framework.change.echange.EChange
import tools.vitruv.framework.change.echange.SubtractiveEChange
import tools.vitruv.framework.change.echange.eobject.CreateEObject
import tools.vitruv.framework.change.echange.eobject.DeleteEObject
import tools.vitruv.framework.change.echange.eobject.EObjectAddedEChange
import tools.vitruv.framework.change.echange.eobject.EObjectSubtractedEChange
import tools.vitruv.framework.change.echange.feature.attribute.SubtractiveAttributeEChange
import tools.vitruv.framework.change.echange.feature.reference.InsertEReference
import tools.vitruv.framework.change.echange.feature.reference.RemoveEReference
import tools.vitruv.framework.change.echange.feature.reference.ReplaceSingleValuedEReference
import tools.vitruv.framework.change.echange.feature.reference.UpdateReferenceEChange
import tools.vitruv.framework.change.echange.root.InsertRootEObject
import tools.vitruv.framework.change.echange.root.RemoveRootEObject

type Command wraps Command
type ResourceSet wraps ResourceSet
type EObj wraps EObject

/**
 * Abstract EChange which is a sequence of several atomic changes.
 */
abstract class CompoundEChange extends tools.vitruv.framework.change.echange.EChange {
	/**
	 * Returns the atomic changes of the compound changes, in the same order as they are 
	 * resolved / applied.
	 */
	op unique AtomicEChange[+] getAtomicChanges()
	
	/**
	 * Returns if all proxy EObjects of the change are resolved to concrete EObjects of a resource set.
	 * Needs to be true to apply the change.
	 * @return	All proxy EObjects are resolved to concrete EObjects.
	 */	
	op boolean isResolved() {
		for (AtomicEChange change : getAtomicChanges()) {
			if (!change.isResolved()) {
				return false
			}
		}
		return super.isResolved()
	}	

	/**
	 * Creates a copy of the change and resolves the unresolved proxy EObjects of the change to a given set of 
	 * resources with concrete EObjects.
	 * The model has to be in the state before the change is applied forward. If the model is in state after the
	 * change and it will be applied backward, {@link resolveAfter} has to be called instead.
	 * Before the change can be applied all proxy objects need to be resolved.
	 * @param 	resourceSet The {@code ResourceSet} which contains the concrete EObjects the proxy objects of
	 * 			the unresolved should be resolved to.
	 * @return 	Returns a resolved copy of the change. If the copy could not be resolved or the resource set
	 * 			is {@code null}, it returns {@code null}. If the change was already resolved, it returns
	 * 			the original change.
	 */
	op EChange resolveBefore(ResourceSet resourceSet) {
		if (!isResolved) {
			val change = EcoreUtil.copy(this)
			if (CompoundEChangeResolver.resolve(change, resourceSet, true, true)) {
				return change
			}
			return null		
		}
		return this
	}
	
	/**
	 * Creates a copy of the change and resolves the unresolved proxy EObjects of the change to a given set 
	 * of resources with concrete EObjects.
	 * The model has to be in the state after the change is applied backward. If the model is in state before
	 * the change and it will be applied forward, {@link resolveBefore} has to be called instead.
	 * Before the change can be applied all proxy objects need to be resolved.
	 * @param 	resourceSet The {@code ResourceSet} which contains the concrete EObjects the proxy objects of
	 * 			the unresolved should be resolved to.
	 * @return 	Returns a resolved copy of the change. If the copy could not be resolved or the resource set
	 * 			is {@code null}, it returns {@code null}. If the change was already resolved, it returns
	 * 			the original change.
	 */
	op EChange resolveAfter(ResourceSet resourceSet) {
		if (!isResolved) {
			val change = EcoreUtil.copy(this)
			if (CompoundEChangeResolver.resolve(change, resourceSet, false, true)) {
				return change
			}
			return null			
		}
		return this
	}	
	
	/**
	 * Resolves the compound change like {@link resolveBefore}, but also applies the change forward.
	 * If the change was already resolved, it returns the original change and applies it forward.
	 * @param 	resourceSet The {@code ResourceSet} which contains the concrete EObjects the proxy objects of
	 * 			the unresolved should be resolved to.
	 * @return 	Returns the resolved change if the change could be applied forward. The returned change
	 * 			is a copy of the change or, if the change was already resolved, the original change. 
	 * 			If the change could not be resolved and / or applied or the 
	 * 			resource set is {@code null}, it returns {@code null}
	 */
	op EChange resolveBeforeAndApplyForward(ResourceSet resourceSet) {
		if (!isResolved) {
			val change = EcoreUtil.copy(this)
			if (CompoundEChangeResolver.resolve(change, resourceSet, true, false)) {
				return change
			}		
		} else {
			if (applyForward) {
				return this
			}
		}
		return null
	}

	/**
	 * Resolves the compound change like {@link resolveAfter}, but also applies the change backward.
	 * If the change was already resolved, it returns the original change and applies it backward.
	 * @param 	resourceSet The {@code ResourceSet} which contains the concrete EObjects the proxy objects of
	 * 			the unresolved should be resolved to.
	 * @return 	Returns the resolved change if the change could be applied backward. The returned change
	 * 			is a copy of the change or, if the change was already resolved, the original change. 
	 * 			If the change could not be resolved and / or applied or the resource set is {@code null}, 
	 * 			it returns {@code null}
	 */	
	op EChange resolveAfterAndApplyBackward(ResourceSet resourceSet) {
		if (!isResolved) {
			val change = EcoreUtil.copy(this)
			if (CompoundEChangeResolver.resolve(change, resourceSet, false, false)) {
				return change
			}	
		} else {
			if (applyBackward) {
				return this				
			}
		}
		return null
	}
}

/**
 * 
 */
class MoveEObject<A extends EObj, B extends EObj, T extends EObj> extends CompoundEChange {
	refers UpdateReferenceEChange<A> subtractWhereChange
	contains EObjectSubtractedEChange<T>[1] subtractWhatChange
	refers UpdateReferenceEChange<B> addWhereChange
	contains EObjectAddedEChange<T>[1] addWhatChange
	op unique AtomicEChange[+] getAtomicChanges() {
		val list = new BasicEList<AtomicEChange>();
		val subWhereChange = getSubtractWhereChange();
		if (subWhereChange != null) {
			list.add(subWhereChange);
		}
		list.add(getSubtractWhatChange());
		val addWhereChange = getAddWhereChange();
		if (addWhereChange != null) {
		    list.add(addWhereChange);
		}
		list.add(getAddWhatChange());
		
		return list;
		
	}
}

/**
 * Abstract EChange which unsets a single or many valued feature.
 */
abstract class ExplicitUnsetEFeature<A extends EObj, F extends EStructuralFeature> extends CompoundEChange {
	refers A[1] affectedEObject
	refers F[1] affectedFeature
}

/**
 * EChange which unsets a single or many valued attribute.
 */
class ExplicitUnsetEAttribute<A extends EObj, T extends Object> extends ExplicitUnsetEFeature<A, EAttribute>, CompoundSubtraction<T, SubtractiveAttributeEChange<A,T>> {
	op unique AtomicEChange[+] getAtomicChanges() {
		return subtractiveChanges.map[it]
	}
}

/**
 * EChange which unsets a single or many valued reference.
 */
class ExplicitUnsetEReference<A extends EObj> extends ExplicitUnsetEFeature<A, EReference> {
	contains EChange[+] changes
	/**
	 * Returns the changes this unset consists of. Can also be compound changes, e.g., a RemoveAndDeleteNonRoot
	 */
	op unique EChange[+] getContainedChanges() {
		return changes;
	}
	op unique AtomicEChange[+] getAtomicChanges() {
		changes.map[
			if (it instanceof AtomicEChange) 
				#[it] 
			else if (it instanceof CompoundEChange) 
				it.atomicChanges 
			else 
				throw new IllegalArgumentException
		].flatten.asEList
	}
}

/** 
 * EChange which replaces an EObject in an EList.
 */
//class ReplaceInEList<A extends EObj, F extends EStructuralFeature, T extends EObj, R extends RemoveFromListEChange<A, F, T> & FeatureEChange<A, F> & SubtractiveEChange<T>, I extends InsertInListEChange<A, F, T> & FeatureEChange<A, F> & AdditiveEChange<T>> extends CompoundEChange {
//	contains R[1] removeChange
//	contains I[1] insertChange
//	op unique AtomicEChange[+] getAtomicChanges() {
//		val list = new BasicEList<AtomicEChange>();
//		list.add(getRemoveChange());
//		list.add(getInsertChange());
//		return list;
//	}
//}

/**
 * Abstract change which combines several subtractive EChanges of the same type.
 */
abstract class CompoundSubtraction<T extends Object, S extends SubtractiveEChange<T>> extends CompoundEChange {
	contains S[+] subtractiveChanges
	op unique AtomicEChange[+] getAtomicChanges() {
		val result = new BasicEList<AtomicEChange>();
		result.addAll(subtractiveChanges);
		return result;
	}
}

/**
 * Abstract change which combines several additive EChanges of the same type.
 */
abstract class CompoundAddition<T extends Object, S extends AdditiveEChange<T>> extends CompoundEChange {
	contains S[+] additiveChanges
	op unique AtomicEChange[+] getAtomicChanges() {
		val result = new BasicEList<AtomicEChange>();
		result.addAll(additiveChanges);
		return result;
	}
}


/** 
 *  Abstract EChange which creates a new EObject and inserts it in a reference. 
 */
abstract class CreateAndInsertEObject<T extends EObj, C extends EObjectAddedEChange<T>> extends CompoundEChange {
	contains CreateEObject<T>[1] createChange
	contains C[1] insertChange
	op unique AtomicEChange[+] getAtomicChanges() {
		val result = new BasicEList();
		result.add(createChange);
		result.add(insertChange);
		return result;
	}
}


/**
 * Abstract EChange which removes an EObject from a reference and deletes it.
 */
abstract class RemoveAndDeleteEObject<T extends EObj, C extends EObjectSubtractedEChange<T>> extends CompoundEChange {
	contains C[1] removeChange
	contains DeleteEObject<T>[1] deleteChange
	op unique AtomicEChange[+] getAtomicChanges() {
		val result = new BasicEList();
		result.add(removeChange);
		result.add(deleteChange);
		return result;
	}
}


/** 
 * EChange which creates and inserts a new root EObject in a resource.
 */
class CreateAndInsertRoot<T extends EObj> extends CreateAndInsertEObject<T, InsertRootEObject<T>> {}


/**
 * EChange which removes an existing EObject from a resource and deletes it.
 */
class RemoveAndDeleteRoot<T extends EObj> extends RemoveAndDeleteEObject<T, RemoveRootEObject<T>> {}


/**
 * EChange which creates and inserts a new EObject into a containment reference. 
 */
class CreateAndInsertNonRoot<A extends EObj, T extends EObj> extends CreateAndInsertEObject<T, InsertEReference<A, T>> {}


/**
 * EChange which removes an existing EObject from a many valued containment reference and deletes it.
 */
class RemoveAndDeleteNonRoot<A extends EObj, T extends EObj> extends RemoveAndDeleteEObject<T, RemoveEReference<A, T>> {}

/**
 * EChange which creates a new EObject and replaces null in a single valued reference.
 */
class CreateAndReplaceNonRoot<A extends EObj, T extends EObj> extends CreateAndInsertEObject<T, ReplaceSingleValuedEReference<A, T>> {}

/**
 * EChange which replaces an existing EObject with null in a single valued reference and deletes it.
 */
class ReplaceAndDeleteNonRoot<A extends EObj, T extends EObj> extends RemoveAndDeleteEObject<T, ReplaceSingleValuedEReference<A, T>> {}

/**
 * EChange creates a new EObject and replaces an existing one in a single valued containment reference. The old one will be deleted.
 */
class CreateAndReplaceAndDeleteNonRoot<A extends EObj, T extends EObj> extends CompoundEChange {
	contains CreateEObject<T>[1] createChange
	contains ReplaceSingleValuedEReference<A, T>[1] replaceChange
	contains DeleteEObject<T>[1] deleteChange
	op unique AtomicEChange[+] getAtomicChanges() {
		val result = new BasicEList();
		result.add(createChange);
		result.add(replaceChange);
		result.add(deleteChange);
		return result;
	}
}
